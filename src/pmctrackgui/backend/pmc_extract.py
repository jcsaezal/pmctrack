#!/usr/bin/python
# -*- coding: utf-8 -*-

#
# pmc_extract.py
# Component for getting data from pmctrack command-line tool.
#
##############################################################################
#
# Copyright (c) 2015 Jorge Casas <jorcasas@ucm.es>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#
##############################################################################

import threading
import time
import os
import signal
from subprocess import Popen, PIPE

class PMCExtract(object):
	def __init__(self, user_config):
		self.user_config = user_config

                # Dictionary data extracted from pmctrack command. Format: data[pid/cpu][nr_experiment][nr_metrc][pos_data]
		self.data = {}

		# Char that indicates the benchmark's state: running (R), stopped (S), killed (K) or finished (F)
		self.state = 'R'

		# Stores benchmark's pid that is monitoring pmctrack (only in per-thread mode)
		self.pid = None

                # Indicates if monitoring data is from a thread or a CPU
                if self.user_config.system_wide:
                    self.pack = "cpu"
                else:
                    self.pack = "pid"

		# If different from None, it contains an error string from the pmctrack command
		self.error = None

		# Creation of pipe to get pmctrack command data
		if not self.user_config.machine.is_remote:
			self.pipe = Popen(self.__get_command().split(), stdout=PIPE, stderr=PIPE)
		else:
			comando = self.user_config.machine.GetSSHCommand().split()
			comando.append("-t")
			comando.append(self.__get_command())
			self.pipe = Popen(comando, stdout=PIPE, stderr=PIPE)
				
		# Dictionary containing column position in which each field is located in the pmctrack command
		self.pos = {}
		ind_h = 0
		line_head = self.pipe.stdout.readline()
		# The following while discard stdout lines that do not correspond with the header of the pmctrack command
		while line_head != '' and (line_head.find("nsample") < 0 or line_head.find(self.pack) < 0 or line_head.find("event") < 0):
			line_head = self.pipe.stdout.readline()
		for header in line_head.split():
			self.pos[header] = ind_h
			ind_h += 1

		# If it failed to read the header is that there has been a mistake.
		if line_head == '':
			err = self.pipe.stderr.read()
			if err.find("pmctrack: ") >= 0: self.error = err.split("pmctrack: ")[1].split('\n')[0]
			else: self.error = err

		# File descriptor if there is a directory configuring to save the results
		self.out = None
		if self.user_config.path_outfile != None:
			if self.user_config.machine.is_remote:
				machine = self.user_config.machine.remote_address
			else:
				machine = _("local")
			self.out = open(self.user_config.path_outfile + "/pmctrack_{0}_{1}.log".format(machine, time.strftime("%d.%m.%y-%H.%M.%S")), "w")
			self.out.write(_("Generated by PMCTrack GUI on {0}").format(time.strftime("%c")) + "\n\n")
			self.out.write(_("Command launched on '{0}':").format(machine) + "\n")
			self.out.write(self.__get_command() + "\n\n")
			self.out.write(line_head)

		# Thread responsible for processing pmctrack command data keeping them in an organized self.data dictionary
		self.thread_extract = None
		if self.error == None:
                	self.thread_extract = threading.Thread(target = self.__extract_information)
			self.thread_extract.start()

	def StopMonitoring(self):
                if self.user_config.system_wide:
                    self.__pause_resume_syswide("pause")
                else:
		    self.__send_signal_to_benchmark("SIGSTOP")
		self.state = 'S'

	def ResumeMonitoring(self):
                if self.user_config.system_wide:
                    self.__pause_resume_syswide("resume")
                else:
		    self.__send_signal_to_benchmark("SIGCONT")
		self.state = 'R'
		
	def KillMonitoring(self):
                os.kill(self.pipe.pid, signal.SIGKILL)
		self.state = 'K'

	def __send_signal_to_benchmark(self, str_signal):
		if self.pid != None and self.state not in ['F', 'K']:
			if not self.user_config.machine.is_remote:
				Popen(("kill -s " + str_signal + " " + self.pid).split())
			else:
				comando = self.user_config.machine.GetSSHCommand().split()
				comando.append("kill -s " + str_signal + " " + self.pid)
				Popen(comando)

        def __pause_resume_syswide(self, arg):
			if not self.user_config.machine.is_remote:
				Popen(("echo -n syswide " + arg + " > /proc/pmc/enable").split())
			else:
				comando = self.user_config.machine.GetSSHCommand().split()
				comando.append("echo -n syswide " + arg + " > /proc/pmc/enable")
				Popen(comando)

	
	def __extract_information(self):
		for line in iter(self.pipe.stdout.readline, ''):
			if self.out != None:
				self.out.write(line)
			field = line.split()
			pack = field[self.pos[self.pack]]

                        # If this is the first time the pack (PID or CPU) appears, prepare the structure of arrays
			if not pack in self.data:
				if not self.user_config.system_wide and self.pid == None:
					self.pid = pack
				self.data[pack] = []
				for num_exp in range(len(self.user_config.experiments)):
					self.data[pack].append([])
					for num_metric in range(len(self.user_config.experiments[num_exp].metrics)):
						self.data[pack][num_exp].append([])
						self.data[pack][num_exp][num_metric] = []

			if len(self.user_config.experiments) > 1: num_exp = int(field[self.pos["expid"]])
			else: num_exp = 0

			num_metric = 0
			for metric_conf in self.user_config.experiments[num_exp].metrics:
				try:
					self.data[pack][num_exp][num_metric].append(eval(metric_conf.metric))
				except ZeroDivisionError:
					self.data[pack][num_exp][num_metric].append(0.0)
				num_metric += 1
		if self.state != 'K': self.state = 'F'
		if self.out != None:
			self.out.close()
	
	# Returns the string of an experiment (-c pmctrack command optiom) previously set by the user
	def __get_experiments_command(self, num_experiment):
		str_experiment = ""
		for eventHW in self.user_config.experiments[num_experiment].eventsHW:
            		# Build event
			str_experiment += ("pmc" if len(str_experiment) == 0 else ",pmc") + str(eventHW.num_counter)
			if not eventHW.fixed:
				str_experiment += "=" + eventHW.code
        			# Build flags
            			str_flags = ""
	    			for flag_name in eventHW.flags.keys():
					str_flags += "," + flag_name + str(eventHW.num_counter) + "=" + eventHW.flags[flag_name]
            			str_experiment += str_flags
                ebs_counter = self.user_config.experiments[num_experiment].ebs_counter
                ebs_value = self.user_config.experiments[num_experiment].ebs_value
                if ebs_counter >= 0:
                    str_experiment += ",ebs" + str(ebs_counter) + "=" + ebs_value
		return str_experiment

        # Returns pmctrack command generated from user settings
	def __get_command(self):
		str_command = "pmctrack -L -r"
                str_command += " -T " + "{0:.2f}".format(float(self.user_config.time) / 1000)
                if self.user_config.system_wide:
                    str_command += " -S"

                if self.user_config.cpu != None:
		    str_command += " -b " + self.user_config.cpu
		
                for num_exp in range(len(self.user_config.experiments)):
		    str_experiment = self.__get_experiments_command(num_exp)
		    if str_experiment != "":
			str_command += " -c " + str_experiment

                if self.user_config.buffer_size > 0:
                    str_command += " -k " + str(self.user_config.buffer_size)
		
                if len(self.user_config.virtual_counters) > 0:
                    str_command += " -V "
                    for i in range(len(self.user_config.virtual_counters)):
                        str_command += "virt" + str(self.user_config.virtual_counters[i])
                        if i < len(self.user_config.virtual_counters) - 1:
                            str_command += ","

                str_command += " " + self.user_config.path_benchmark
		if self.user_config.args_benchmark != "":
			str_command += " " + self.user_config.args_benchmark
                return str_command
